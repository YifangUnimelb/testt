[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "",
    "text": "Abstract. This paper forecasts Australian inflation and interest rate using Bayesian Vector Auto Regressive Model with stochastic volatility and a multivariate-t distributed error, with the purpose of allowing time varying volatility and the error to capture sudden increases in volatility during periods with extreme events such as the COVID-19 pandemic. It is an application of such method, which is often considered as a significant improvement over a standard BVAR, to Australian macroeconomic variables to generate spot and density forecasts using post-COVID data."
  },
  {
    "objectID": "index.html#time-series-plot",
    "href": "index.html#time-series-plot",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "Time Series Plot",
    "text": "Time Series Plot\nThe following are the time series plot all variables."
  },
  {
    "objectID": "index.html#acf-and-pacf",
    "href": "index.html#acf-and-pacf",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "ACF and PACF",
    "text": "ACF and PACF\nThe following ACF plots of all transformed variables show autocorrelation over a large number of lags, therefore, likely to be non-stationary.\n\n\n\n\n\n\n\n\n\nIn PACF plots, significant correlations were only observed in the first lag for variables except for unemployment rate. It demonstrates partial autocorrelation for the first and second lag, also in some lags order 15 to 20."
  },
  {
    "objectID": "index.html#augmented-dickey-fuller",
    "href": "index.html#augmented-dickey-fuller",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "Augmented Dickey-Fuller",
    "text": "Augmented Dickey-Fuller\nThe table shows the result of Augmented Dickey-Fuller test. All time series are non-stationary at 5% significance level except for cash rate in this test.\n\n\n\n\n\nvariable\np_value\nnon_stationary\n\n\n\n\ncpi_log\n0.1161\n1\n\n\ngdp_log\n0.8745\n1\n\n\nm1_log\n0.1178\n1\n\n\nex\n0.6245\n1\n\n\ncr\n0.0107\n0\n\n\nun_em\n0.3862\n1\n\n\n\n\n\nThe table shows the result of Augmented Dickey-Fuller test using the first-differenced data. All variables are integrated of order 1.\n\n\n\n\n\nvariable\np_value\nnon_stationary\n\n\n\n\ncpi_log\n0.0180\n0\n\n\ngdp_log\n0.0100\n0\n\n\nm1_log\n0.0219\n0\n\n\nex\n0.0100\n0\n\n\ncr\n0.0177\n0\n\n\nun_em\n0.0100\n0"
  },
  {
    "objectID": "index.html#the-baseline-model",
    "href": "index.html#the-baseline-model",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "The Baseline Model",
    "text": "The Baseline Model\nThe baseline model is the standard form where \\(\\Omega\\) = \\(I_T\\). With predictive density:\n\\[Y|X,A,\\Sigma \\sim MN_{T \\times N} (XA, \\Sigma, I_T)\\] Therefore the kernel of the likelihood function: \\[L(A,\\Sigma|Y,X) \\propto det(\\Sigma)^{-\\frac{T}{2}}exp(-\\frac{1}{2}tr[\\Sigma^{-1}(Y-XA)'(Y-XA)])\\] The matrix-variate normal and inverse Wishart natural conjugate priors for \\(A\\) and \\(\\Sigma\\):\n\\[p(A,\\Sigma) = p(A|\\Sigma)p(\\Sigma)\\] \\[A|\\Sigma = MN_{K\\times N}(\\underline{A},\\Sigma,\\underline{V})\\] \\[\\Sigma \\sim IW_N(\\underline{S},\\underline{\\nu})\\] Therefore the kernel of the prior distribution:\n\\[\n\\begin{align}\np(A,\\Sigma) &\\propto  \\det(\\Sigma)^{-\\frac{N+K+\\underline{v}+1}{2}} \\\\\n&\\times exp\\{-\\frac{1}{2}tr[\\Sigma^{-1}(A-\\underline{A}) \\underline{V}^{-1}(A-\\underline{A})]\\} \\\\\n&\\times exp\\{-\\frac{1}{2}tr[\\Sigma^{-1}\\underline{S}]\\}\n\\end{align}\n\\]\nDerive the product of the likelihood function and the density function \\(p(A,\\Sigma)\\):\n\\[p(A,\\Sigma|Y,X) \\propto L(A,\\Sigma|Y,X)p(A,\\Sigma) \\] Collect corresponding terms and then we have the full conditional posterior distribution:\n\\[A|\\Sigma = MN_{K\\times N}(\\bar{A},\\Sigma,\\bar{V})\\] \\[\\Sigma \\sim IW_N(\\bar{S},\\bar{\\nu})\\] where the parameters are:\n\\[\\bar{V} = (X'X + \\underline{V}^{-1})^{-1}\\]\n\\[\\bar{A} = \\bar{V}(X'Y + \\underline{V}^{-1}\\underline{A})\\] \\[\\bar{S} = \\underline{S}+Y'Y + \\underline{A}'\\underline{V}^{-1}\\underline{A}-\\bar{A}'\\bar{V}^{-1}\\bar{A}\\] \\[\\bar{\\nu}= T + \\underline{\\nu}\\] To accommodate non-stationary data, we use minnesota prior:\n\\[\\underline{A} = [0_{N\\times1}   \\space\\space  I_N    \\space\\space 0_{N \\times (p-1N) }]'\\] \\[\\underline{V} = diag([\\kappa_{2} \\space \\space  \\kappa_{1} (p^{-2} \\otimes i_{N}')])\\] This prior assumes the macroeconomic time-series leans towards a random walk given that except for first lag, all other slope parameters in \\(\\underline{A}\\) are zero. The shrinkage parameters in \\(\\underline{V}\\) are set to be \\(\\kappa_{2}\\), a relatively large value as there is little information about the intercept parameters. And for slope parameters, \\(\\kappa_{1}\\) will be significantly smaller and decreasing over lags.\nThe following function represents the estimation procedure:\n\n#Function form of basic model\n\nbvar_est = function(Y,X,p){\n  \n  #set parameters\n  t = nrow(Y)\n  N = ncol(Y) #number of variables\n  S = 500 #number of draws\n  \n  #mle\n  A.hat  = solve(t(X)%*%X)%*%t(X)%*%Y\n  Sigma.hat  = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/t\n  \n  # minnesota prior\n  k1     = 0.02^2\n  k2     = 100\n  A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))\n  A.prior[2:(1+N),] = diag(N)\n  V.prior     = diag(c(k2,k1*((1:p)^(-2))%x%rep(1,N)))\n  S.prior     = diag(diag(Sigma.hat))\n  nu.prior    = N+1\n  \n  # NIW posterior\n\n  V.bar.inv   = t(X)%*%X + diag(1/diag(V.prior))\n  V.bar       = solve(V.bar.inv)\n  A.bar       = V.bar%*%(t(X)%*%Y + diag(1/diag(V.prior))%*%A.prior)\n  nu.bar      = nrow(Y) + nu.prior\n  S.bar       = S.prior + t(Y)%*%Y + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar  \n  S.bar.inv   = solve(S.bar)\n  \n  #draws from posterior\n\n  Sigma.posterior   = rWishart(S, df=nu.bar, Sigma=S.bar.inv)\n  Sigma.posterior   = apply(Sigma.posterior,3,solve)\n  Sigma.posterior   = array(Sigma.posterior,c(N,N,S))\n  A.posterior       = array(rnorm(prod(c(dim(A.bar),S))),c(dim(A.bar),S))\n  L                 = t(chol(V.bar))\n\n  for (s in 1:S){\n    A.posterior[,,s]= A.bar + L%*%A.posterior[,,s]%*%chol(Sigma.posterior[,,s])\n  }\n\n  round(apply(A.posterior,1:2,mean),3)\n\n  # report posterior means and sd of parameters\n  A.E         = apply(A.posterior,1:2,mean)\n  Sigma.E     = apply(Sigma.posterior,1:2,mean)\n\n  output = list(\n    A.E = A.E,\n    Sigma.E = Sigma.E,\n    A.posterior.draws = A.posterior,\n    Sigma.posterior.draws = Sigma.posterior\n  )\n  return(output)\n}"
  },
  {
    "objectID": "index.html#posterior-draws",
    "href": "index.html#posterior-draws",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "Posterior Draws",
    "text": "Posterior Draws\nFor matrix \\(A\\):\n\nhead(round(apply(baseline.posterior.draws$A.posterior.draws,1:2,base::mean),6))\n\n          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]\n[1,]  0.007059  0.006940  0.026231  0.000326  0.043270 -0.055705\n[2,]  1.000008  0.000000 -0.000052 -0.000005  0.000752 -0.000145\n[3,]  0.000008  0.999993  0.000007 -0.000015  0.000583  0.000416\n[4,]  0.000032 -0.000029  0.999915 -0.000064  0.002915 -0.000174\n[5,] -0.000007 -0.000007 -0.000042  0.999928 -0.000244  0.000379\n[6,] -0.000036 -0.000028 -0.000141 -0.000102  0.987171  0.007317\n\n\nFor matrix \\(\\Sigma\\):\n\nhead(round(apply(baseline.posterior.draws$Sigma.posterior.draws,1:2,base::mean),6))\n\n          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]\n[1,]  0.000034  0.000016 -0.000034  0.000031  0.001082 -0.000711\n[2,]  0.000016  0.000103 -0.000013  0.000059  0.000548 -0.001363\n[3,] -0.000034 -0.000013  0.000631 -0.000060 -0.004225  0.001102\n[4,]  0.000031  0.000059 -0.000060  0.001295  0.004123 -0.001230\n[5,]  0.001082  0.000548 -0.004225  0.004123  0.189818 -0.061517\n[6,] -0.000711 -0.001363  0.001102 -0.001230 -0.061517  0.087291\n\n\n\nTrace Plot\nThe following diagrams are the trace plots and histograms of the first lag auto-correlative parameter for variable \\(CPI \\underline{} log_t\\) in the \\(A\\) matrices in the posterior draws. The autocorrelation is significant while the variance is quite small.\n\npar(mfrow=c(2,2), mar=c(4,4,2,2))\n\nplot.ts(baseline.posterior.draws$A.posterior.draws[2,1,], xlab = \"Simulation times S\", ylab = \"CPI\", col = mcxs1)\nhist(baseline.posterior.draws$A.posterior.draws[2,1,], xlab = \"CPI\", col = mcxs1, main = '')\n\nplot.ts(baseline.posterior.draws$Sigma.posterior.draws[1,1,], xlab = \"Simulation times S\", ylab = \"CPI sigma\", col = mcxs2)\nhist(baseline.posterior.draws$Sigma.posterior.draws[1,1,], xlab = \"CPI sigma\", col = mcxs2, main = '')\n\n\n\n\n\n\n\n\nSimilarly, for \\(CR_t\\), the autocorrelation is significant. Its variance is visibly larger than the previous variable.\n\npar(mfrow=c(2,2), mar=c(4,4,2,2))\n\nplot.ts(baseline.posterior.draws$A.posterior.draws[6,5,], xlab = \"Simulation times S\", ylab = \"Cash Rate\", col = mcxs1)\nhist(baseline.posterior.draws$A.posterior.draws[6,5,], xlab = \"Cash Rate\", col = mcxs1, main = '')\n\nplot.ts(baseline.posterior.draws$Sigma.posterior.draws[5,5,], xlab = \"Simulation times S\", ylab = \"Cash Rate sigma\", col = mcxs2)\nhist(baseline.posterior.draws$Sigma.posterior.draws[5,5,], xlab = \"Cash Rate sigma\", col = mcxs2, main = '')"
  },
  {
    "objectID": "index.html#the-extended-model-1---student-t-distributed-error-bvar-t",
    "href": "index.html#the-extended-model-1---student-t-distributed-error-bvar-t",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "The Extended Model 1 - Student-t Distributed Error (BVAR-t)",
    "text": "The Extended Model 1 - Student-t Distributed Error (BVAR-t)\nThe model is where \\(\\Omega\\) = \\(diag(\\lambda_1, \\lambda_2,...,\\lambda_T)\\). Each lambda independently drawn from an Inverse Gamma 2 distribution \\(IG2(\\nu-2,\\nu)\\). This implies the distribution of error term being:\n\\[ \\epsilon_t \\sim N(0, \\lambda_t \\Sigma)\\]\ncompared to the baseline model, the error distribution has fatter tails which captures sudden spike of variance.The predictive density:\n\\[Y|X,A,\\Sigma \\sim MN_{T \\times N} (XA, \\Sigma, \\Omega)\\] Therefore the kernel of the likelihood function:\n\\[L(A,\\Sigma,\\Omega|Y,X) \\propto det(\\Omega)^{-\\frac{N}{2}}det(\\Sigma)^{-\\frac{T}{2}}exp(-\\frac{1}{2}tr[\\Sigma^{-1}(Y-XA)'\\Omega^{-1}(Y-XA)])\\] I assume the same matrix-variate normal and inverse Wishart natural conjugate priors for \\(A\\) and \\(\\Sigma\\). Derive the product of the likelihood function and the density function \\(p(A,\\Sigma)\\), collect corresponding terms and then we have the full conditional posterior distribution:\n\\[A|\\Sigma = MN_{K\\times N}(\\bar{A},\\Sigma,\\bar{V})\\] \\[\\Sigma \\sim IW_N(\\bar{S},\\bar{\\nu})\\] where the parameters are:\n\\[\\bar{V} = (X'\\Omega^{-1}X + \\underline{V}^{-1})^{-1}\\]\n\\[\\bar{A} = \\bar{V}(X'\\Omega^{-1}Y + \\underline{V}^{-1}\\underline{A})\\] \\[\\bar{S} = \\underline{S}+Y'\\Omega^{-1}Y + \\underline{A}'\\underline{V}^{-1}\\underline{A}-\\bar{A}'\\bar{V}^{-1}\\bar{A}\\] \\[\\bar{\\nu}= T + \\underline{\\nu}\\] To derive the full conditional posterior for \\(\\lambda_t\\), the kernel of likelihood function can be expressed as:\n\\[L(A,\\Sigma,\\Omega|Y,X) \\propto det(\\Omega)^{-\\frac{N}{2}}exp(-\\frac{1}{2}tr[\\Sigma^{-1}(Y-XA)'\\Omega^{-1}(Y-XA)])\\] \\[= (\\prod^{T}_{i = 1} \\lambda_t^{-\\frac{N}{2}})exp({-\\frac{1}{2}}{\\frac{1}{\\lambda_t}} \\sum^{T}_{i =1}\\epsilon_t' \\Sigma^{-1}\\epsilon_t)\\] That is for each \\(t\\), the likelihood function is:\n\\[ \\lambda_t^{-\\frac{N}{2}}exp({-\\frac{1}{2}}{\\frac{1}{\\lambda_t}} \\epsilon_t' \\Sigma^{-1}\\epsilon_t)\\] The density function for \\(\\lambda_t \\sim IG2(\\nu_{\\lambda}-2,\\nu_{\\lambda})\\) is:\n\\[\\lambda_t^{-\\frac{\\nu_{\\lambda}-2+2}{2}}exp({-\\frac{1}{2}}{\\frac{\\nu_{\\lambda}}{\\lambda_t}})\\] The posterior density for \\(\\lambda_t\\) is:\n\\[p(\\lambda_t|Y,X,A,\\Sigma,\\nu_{\\lambda})= \\lambda_t^{-\\frac{N+\\nu_{\\lambda}+2}{2}}exp[{-\\frac{1}{2}}{\\frac{1}{\\lambda_t}}(\\nu_{\\lambda}-2+\\epsilon_t' \\Sigma^{-1}\\epsilon_t))]\\] Which is: with \\[\\epsilon_t = (y_t- x_t'A).\\] The posterior follows an \\(IG2\\) distribution: \\[\\lambda_t|Y,X,A,\\Sigma,\\nu_{\\lambda} \\sim IG2(\\bar\\nu_{\\lambda},\\bar{s}_{\\lambda})\\] \\[\\bar\\nu_{\\lambda} = N+\\underline\\nu_{\\lambda}\\] \\[\\bar{s}_{\\lambda} =\\underline\\nu_{\\lambda}-2+\\epsilon_t' \\Sigma^{-1}\\epsilon_t\\] Here, we need a gibb sampler to estimate each parameter. I initialize a \\(\\Omega^{(0)}\\), which is a diagonal matrix with each element \\(\\lambda_t\\) drawn from \\(IG2(\\underline\\nu_{\\lambda}-2,\\underline\\nu_{\\lambda})\\) and let \\(\\bar\\nu_{\\lambda}=5\\).Then:\n\nDraw \\(\\Sigma^{(s)}\\) from \\(IW_N(\\bar{S},\\bar{\\nu})\\).\nDraw \\(A^{(s)}\\) from \\(MN_{K\\times N}(\\bar{A},\\Sigma^{(s)},\\bar{V})\\).\n\nThen for each iteration \\(s\\), I draw \\(T\\) \\(\\lambda_t\\) using corresponding row in the error matrix:\n\nDraw \\(\\lambda_t^{(s)}\\) from \\(IG2(\\bar\\nu_{\\lambda},\\bar{s}_{\\lambda})\\).\n\nThen form \\(\\Omega^{(s)}\\) with \\(\\lambda_t^{(s)}\\), update all the priors, repeat.\nThe following function represents the estimation procedure:\n\nlibrary(MCMCpack)\n\nbvar_t = function(Y,X,p){\n\n# Set parameters\nS = 1000\nN = ncol(Y)\nt &lt;- nrow(Y)  \n\n#mle\n\nA.hat  = solve(t(X)%*%X)%*%t(X)%*%Y\nSigma.hat  = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/t\n\n#minnesota\n\nk1     = 5\nk2     = 100\nA.prior &lt;- matrix(0,nrow(A.hat),ncol(A.hat))\nA.prior[2:(1+N),] = diag(N)\nV.prior     = diag(c(k2,k1*((1:p)^(-2))%x%rep(1,N)))\nSigma.s.prior    = diag(diag(Sigma.hat))\nSigma.v.prior    = N+1\nlambda.nu.prior = 5\n\n#inital lambda/omega\n\nlambda0 = (lambda.nu.prior-2)/rchisq(t,lambda.nu.prior)\n\n# Initialize arrays to store posterior draws\n  Sigma.posterior.draws = array(NA, c(N,N,S))\n  A.posterior.draws = array(NA, c((1+p*N),N,S))\n  \n  lambda.posterior.draws = array(NA,c(t,S+1))\n  lambda.posterior.draws[,1] = lambda0 \n  lambda.s.posterior = array(NA,c(t,S))\n  \nfor (s in 1:S){ \n    \n    V.posterior     = solve(t(X)%*%diag(1/(lambda.posterior.draws[,s]))%*%X + solve(V.prior))\n    \n    A.posterior     = V.posterior%*%(t(X)%*%diag(1/(lambda.posterior.draws[,s]))%*%Y + solve(V.prior)%*%A.prior)\n    \n    Sigma.s.posterior = t(Y)%*%diag(1/(lambda.posterior.draws[,s]))%*%Y + t(A.prior)%*%solve(V.prior)%*%A.prior + Sigma.s.prior - t(A.posterior)%*%solve(V.posterior)%*%A.posterior\n    \n    Sigma.v.posterior = nrow(Y) + Sigma.v.prior\n    \n    Sigma.posterior.draws[,,s] = riwish(Sigma.v.posterior, Sigma.s.posterior)\n\n    A.posterior.draws[,,s] = matrix(mvtnorm::rmvnorm(1, mean=as.vector(A.posterior), sigma=Sigma.posterior.draws[,,s]%x%V.posterior), ncol=N)\n    \n    E.s = Y-X%*%A.posterior.draws[,,s]\n    \n    for (x in 1:t){\n    lambda.s.posterior[,s] = lambda.nu.prior-2 + t((E.s)[x,])%*%Sigma.posterior.draws[,,s]%*%(E.s)[x,]\n    }\n    \n    lambda.v.posterior = N + lambda.nu.prior\n    \n    for (x in 1:t){\n    lambda.posterior.draws[x,s+1] = lambda.s.posterior[x,s]/rchisq(1,lambda.v.posterior)\n    }\n    \n} \n  output = list(\n    A.posterior.draws = A.posterior.draws,\n    Sigma.posterior.draws = Sigma.posterior.draws,\n    lambda.posterior.draws = lambda.posterior.draws\n  )\n  return(output)\n}\n\n\nTrace Plot\n\npar(mfrow=c(2,2), mar=c(4,4,2,2))\n\nplot.ts(bvart$A.posterior.draws[2,1,], xlab = \"Simulation times S\", ylab = \"CPI\", col = mcxs1)\nhist(bvart$A.posterior.draws[2,1,], xlab = \"CPI\", col = mcxs1, main = '')\n\nplot.ts(bvart$Sigma.posterior.draws[1,1,], xlab = \"Simulation times S\", ylab = \"CPI sigma\", col = mcxs2)\nhist(bvart$Sigma.posterior.draws[1,1,], xlab = \"CPI sigma\", col = mcxs2, main = '')\n\n\n\n\n\n\n\n\n\npar(mfrow=c(2,2), mar=c(4,4,2,2))\n\nplot.ts(bvart$A.posterior.draws[6,5,], xlab = \"Simulation times S\", ylab = \"Cash Rate\", col = mcxs1)\nhist(bvart$A.posterior.draws[6,5,], xlab = \"Cash Rate\", col = mcxs1, main = '')\n\nplot.ts(bvart$Sigma.posterior.draws[5,5,], xlab = \"Simulation times S\", ylab = \"Cash Rate sigma\", col = mcxs2)\nhist(bvart$Sigma.posterior.draws[5,5,], xlab = \"Cash Rate sigma\", col = mcxs2, main = '')"
  },
  {
    "objectID": "index.html#the-extended-model-2---stochastic-volatility-bvar-sv",
    "href": "index.html#the-extended-model-2---stochastic-volatility-bvar-sv",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "The Extended Model 2 - Stochastic Volatility (BVAR-sv)",
    "text": "The Extended Model 2 - Stochastic Volatility (BVAR-sv)\nFor this model, the \\(\\Omega = diag(e^{h1},e^{h2},...,e^{h_T})\\), where \\(h_t\\) follows an AR(1) process:\n\\[h_t = h_{t-1}+\\eta_t\\] where \\(\\eta_{t} \\sim N(0, \\sigma^{2}_{\\eta})\\) and \\(h_0 \\sim N(0, \\delta^2_{\\eta})\\), which implies \\(\\epsilon_{t} \\sim N(0,e^{h_t} \\Sigma)\\).\n\n\nLoading required package: nlme\n\n\n\nAttaching package: 'nlme'\n\n\nThe following object is masked from 'package:dplyr':\n\n    collapse\n\n\nThis is mgcv 1.9-1. For overview type 'help(\"mgcv-package\")'.\n\n\n\nhead(round(apply(A.posterior.sv, 1:2, base::mean),6))         # posterior draw A\n\n          [,1]      [,2]      [,3]      [,4]      [,5]      [,6]\n[1,]  0.004562  0.005230 -0.000777  0.009792  0.255862 -0.200906\n[2,]  0.999840 -0.000528  0.000018 -0.003602 -0.019130  0.056016\n[3,]  0.000465  1.001325  0.002199  0.001110  0.058212 -0.053955\n[4,] -0.000363 -0.002174  0.998443  0.000359 -0.077166  0.072552\n[5,]  0.000134  0.000249 -0.003032  0.989683  0.028422  0.002204\n[6,]  0.001781 -0.000329 -0.006810  0.002848  1.192770 -0.057279\n\nhead(round(apply(Sigma.posterior.sv, 1:2, base::mean),6))     # posterior draw sigma\n\n         [,1]     [,2]      [,3]      [,4]      [,5]      [,6]\n[1,]  2.0e-06  0.0e+00 -0.000001  0.000001  0.000017 -0.000025\n[2,]  0.0e+00  5.0e-06 -0.000001  0.000001  0.000023 -0.000052\n[3,] -1.0e-06 -1.0e-06  0.000029 -0.000005 -0.000107  0.000019\n[4,]  1.0e-06  1.0e-06 -0.000005  0.000090  0.000150 -0.000141\n[5,]  1.7e-05  2.3e-05 -0.000107  0.000150  0.005071 -0.001148\n[6,] -2.5e-05 -5.2e-05  0.000019 -0.000141 -0.001148  0.003804\n\n\n\nTrace Plot\n\npar(mfrow=c(2,2), mar=c(4,4,2,2))\n\nplot.ts(A.posterior.sv[2,1,], xlab = \"Simulation times S\", ylab = \"CPI\", col = mcxs1)\nhist(A.posterior.sv[2,1,], xlab = \"CPI\", col = mcxs1, main = '')\n\nplot.ts(Sigma.posterior.sv[1,1,], xlab = \"Simulation times S\", ylab = \"CPI sigma\", col = mcxs2)\nhist(Sigma.posterior.sv[1,1,], xlab = \"CPI sigma\", col = mcxs2, main = '')\n\n\n\n\n\n\n\n\n\npar(mfrow=c(2,2), mar=c(4,4,2,2))\n\nplot.ts(A.posterior.sv[6,5,], xlab = \"Simulation times S\", ylab = \"Cash Rate\", col = mcxs1)\nhist(A.posterior.sv[6,5,], xlab = \"Cash Rate\", col = mcxs1, main = '')\n\nplot.ts(Sigma.posterior.sv[5,5,], xlab = \"Simulation times S\", ylab = \"Cash Rate sigma\", col = mcxs2)\nhist(Sigma.posterior.sv[5,5,], xlab = \"Cash Rate sigma\", col = mcxs2, main = '')"
  },
  {
    "objectID": "index.html#the-extended-model-3---t-distributed-error-and-stochastic-volatility-bvar-t-sv",
    "href": "index.html#the-extended-model-3---t-distributed-error-and-stochastic-volatility-bvar-t-sv",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "The Extended Model 3 - T-distributed error and Stochastic Volatility (BVAR-t-sv)",
    "text": "The Extended Model 3 - T-distributed error and Stochastic Volatility (BVAR-t-sv)"
  },
  {
    "objectID": "index.html#computational-validity",
    "href": "index.html#computational-validity",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "Computational Validity",
    "text": "Computational Validity\nThe following contains code for the estimation and a results demonstration using a bivariate Gaussian random walk data, with true parameter \\(A = [0_{2 \\times 1} \\space I_2]'\\) and \\(\\Sigma = I_2\\), to demonstrate the computational validity of this method.\n\n\n\n\n\n\n\n\n\nEstimates from Standard BVAR Algorithm:\n\nrw = bvar_est(Y_rw, X_rw, p_rw)\n\n# A posterior mean\nround(rw$A.E,2)\n\n     [,1]  [,2]\n[1,] 0.07  0.12\n[2,] 0.98 -0.02\n[3,] 0.01  0.99\n\n# Sigma posterior mean\nround(rw$Sigma.E,2)\n\n     [,1] [,2]\n[1,] 0.96 0.19\n[2,] 0.19 0.98\n\n\nEstimates from BVAR-t Algorithm:\n\nrw_t = bvar_t(Y_rw, X_rw, p_rw)\n\n# A posterior mean\napply(rw_t$A.posterior.draws, 1:2, base::mean)\n\n           [,1]        [,2]\n[1,] 0.28371696  0.37202065\n[2,] 0.90968007 -0.08108526\n[3,] 0.01931849  0.98384589\n\n# Sigma posterior mean\napply(rw_t$Sigma.posterior.draws, 1:2, base::mean)*mean(rw_t$lambda.posterior.draws[,1])\n\n          [,1]      [,2]\n[1,] 1.7349611 0.3157255\n[2,] 0.3157255 1.7733401\n\n\nEstimates from BVAR-sv Algorithm:\n\nrw_sv = bvar_sv(Y_rw, X_rw, p_rw)\n\n# A posterior mean\napply(rw_sv$A, 1:2, base::mean)\n\n            [,1]        [,2]\n[1,] 0.366862466  0.32099309\n[2,] 0.928928911 -0.02436101\n[3,] 0.002504122  0.96139656\n\n# Sigma posterior mean\napply(rw_sv$Sigma, 1:2, base::mean)*mean(rw_sv$sigma2)\n\n          [,1]      [,2]\n[1,] 183.82624  14.10399\n[2,]  14.10399 173.56744"
  },
  {
    "objectID": "index.html#baseline-model-vs.-t-distributed-error",
    "href": "index.html#baseline-model-vs.-t-distributed-error",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "Baseline Model vs. T-distributed Error",
    "text": "Baseline Model vs. T-distributed Error"
  },
  {
    "objectID": "index.html#stochastic-volatility",
    "href": "index.html#stochastic-volatility",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "Stochastic Volatility",
    "text": "Stochastic Volatility"
  },
  {
    "objectID": "index.html#stochastic-volatility-and-t-distributed-error",
    "href": "index.html#stochastic-volatility-and-t-distributed-error",
    "title": "Forecasting Inflation and Interest Rate in Australia",
    "section": "Stochastic Volatility and T-distributed error",
    "text": "Stochastic Volatility and T-distributed error"
  }
]